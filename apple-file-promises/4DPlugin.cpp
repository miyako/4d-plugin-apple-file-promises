/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Apple file promises
 #	author : miyako
 #	2018/05/14
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

#ifndef errAEEventWouldRequireUserConsent
enum {
    errAEEventWouldRequireUserConsent     =     -1744
};
#endif

void requestPermission(NSString *bundleIdentifier){
    
    if (@available(macOS 10.14, *)) {
        OSStatus status;
        
        /*
         alternatively
         NSAppleEventDescriptor *targetAppEventDescriptor;
         targetAppEventDescriptor = [NSAppleEventDescriptor descriptorWithBundleIdentifier:@"com.apple.Notes"];
         and pass targetAppEventDescriptor.aeDesc to AEDeterminePermissionToAutomateTarget()
         */
        
        AEAddressDesc addressDesc;
        
        const char *bundleIdentifierCString = [bundleIdentifier cStringUsingEncoding:NSUTF8StringEncoding];
        if(AECreateDesc(typeApplicationBundleID, bundleIdentifierCString, strlen(bundleIdentifierCString), &addressDesc) == noErr)
        {
            status = AEDeterminePermissionToAutomateTarget(&addressDesc, typeWildCard, typeWildCard, true);
            AEDisposeDesc(&addressDesc);
            
            switch (status) {
                case errAEEventWouldRequireUserConsent:
                    NSLog(@"Automation permission pending for %@", bundleIdentifier);
                    break;
                case noErr:
                    NSLog(@"Automation permission granted for %@", bundleIdentifier);
                    break;
                case errAEEventNotPermitted:
                    NSLog(@"Automation permission denied for %@", bundleIdentifier);
                    break;
                case procNotFound:
                    NSLog(@"Automation permission unknown for %@", bundleIdentifier);
                    break;
                default:
                    break;
            }
        }
    }
}

Swizzle_XMacNSView_saisierec_Class *swizzle_XMacNSView_saisierec = nil;

static IMP __orig_imp_draggingEntered;
static IMP __orig_imp_draggingUpdated;
static IMP __orig_imp_prepareForDragOperation;
static IMP __orig_imp_performDragOperation;
static IMP __orig_imp_concludeDragOperation;

std::mutex globalMutex; /* PATHS,LISTENER_CONTEXT */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

namespace FilePromise
{
	AppleFilePromiseListener *listener = nil;
	
    //constants
	process_stack_size_t STACK_SIZE = 0;
	const process_name_t PROCESS_NAME = (PA_Unichar *)"$\0A\0F\0P\0\0\0";
	
    //context management
	std::vector<CUTF16String>PATHS;
	C_TEXT LISTENER_CONTEXT;
	
    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
	bool PROCESS_SHOULD_TERMINATE = false;
	bool PROCESS_SHOULD_RESUME = false;
}

NSString *copyDecodedDynUTI(NSString *uti)
{
	/* 
	 * from: https://gist.github.com/jtbandes/19646e7457208ae9b1ad
	 */
	
	NSString *result;
	
	NSUInteger decoded = 0;
	NSUInteger decodedBits = 0;
	NSMutableData *dat = [[NSMutableData alloc]init];
	
	@autoreleasepool
	{
		if(uti)
		{
			if([uti hasPrefix:@"dyn.a"])
			{
				NSArray *arr =
				@[@"a",@"b",@"c",@"d",@"e",
					@"f",@"g",@"h"          ,
					@"k",     @"m",@"n"     ,
					@"p",@"q",@"r",@"s",@"t",
					@"u",@"v",@"w",@"x",@"y",
					@"z",@"0",@"1",@"2",@"3",
					@"4",@"5",@"6",@"7",@"8",
					@"9"];
				
				NSString *encodedString = [uti substringFromIndex:5];
				
				for (NSUInteger counter = 0; counter < encodedString.length; ++counter)
				{
					NSString *substring = [encodedString substringWithRange:NSMakeRange(counter, 1)];
					
					if (![arr containsObject:substring])
					{
						break;
					}
					
					NSUInteger pos = [arr indexOfObject:substring];
					
					decoded = (decoded << 5) | pos;
					decodedBits += 5;
					
					if (decodedBits >= 8)
					{
						NSUInteger extra = decodedBits - 8;
						UInt8 data = (UInt8)(decoded >> extra);
						decoded &= (1 << extra) - 1;
						decodedBits = extra;
						[dat appendBytes:&data length:sizeof(UInt8)];
					}
				}
			}
		}
	}
	
	result = !decoded ? [[NSString alloc]initWithData:dat encoding:NSUTF8StringEncoding] : nil;
	
	[dat release];
	
	return result;
}

NSURL *temporaryDirectory()
{
	NSURL *url = nil;
	
	NSArray *URLs = [[NSFileManager defaultManager]
									 URLsForDirectory:NSDesktopDirectory
									 inDomains:NSUserDomainMask];
	
	if(URLs && [URLs count])
	{
		
		url = [[NSFileManager defaultManager]
					 URLForDirectory:NSItemReplacementDirectory
					 inDomain:NSUserDomainMask
					 appropriateForURL:[URLs objectAtIndex:0]
					 create:YES
					 error:nil];
	}
	
	return url;
}

void generateUuid(C_TEXT &returnValue)
{
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
}

#pragma mark AppleScript

void sb_tell_photos_to_export(NSURL *url)
{
	@autoreleasepool
	{
		PhotosApplication *application = [SBApplication applicationWithBundleIdentifier:@"com.apple.Photos"];
		
		if(application)
		{
			[application
			 export:[application selection]
			 to:url
			 usingOriginals:YES];
		}
	}
}

void sb_tell_mail_to_export(NSURL *url)
{
	@autoreleasepool
	{
		MailApplication *application = [SBApplication applicationWithBundleIdentifier:@"com.apple.mail"];
		
		if(application)
		{
			NSArray *mails = [application selection];
			NSArray *sources = [mails arrayByApplyingSelector:@selector(source)];
            
			NSUInteger i = 0;
			
			NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
			
			for (id source in sources) {
                                
                NSStringEncoding encoding = NSISOLatin1StringEncoding;
				NSString *dst = [path stringByAppendingFormat:@"/%d.%@", ++i, @"eml"];
        
                if([(NSString *)source writeToFile:dst
                                        atomically:YES
                                          encoding:encoding
                                             error:nil]){
                    NSURL *url = [[NSURL alloc]initFileURLWithPath:dst isDirectory:NO];
                    if(url)
                    {
                        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
                        C_TEXT t;
                        t.setUTF16String(path);
                        CUTF16String u16;
                        t.copyUTF16String(&u16);
                        
                        if(1)
                        {
                            std::lock_guard<std::mutex> lock(globalMutex);
                            
                            FilePromise::PATHS.push_back(u16);
                        }
                        
                        [path release];
                        
                        listenerLoopExecute();
                        [url release];
                    }
                }
			}
		}
	}
}

//BUG: quoted printable files are corrupt!

void sb_tell_outlook_to_export(NSURL *url)
{
	@autoreleasepool
	{
		NSArray *runningApplications = [NSRunningApplication runningApplicationsWithBundleIdentifier:@"com.microsoft.Outlook"];
		
		if([runningApplications count])
		{
			OutlookApplication *application = [SBApplication applicationWithProcessIdentifier:[[runningApplications objectAtIndex:0]processIdentifier]];
			
			if(application)
			{
				NSArray *mails = [application selectedObjects];
				NSArray *sources = [mails arrayByApplyingSelector:@selector(source)];
                
				NSUInteger i = 0;
				
				NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
				
				for (id source in sources) {
                    
                    NSStringEncoding encoding = NSISOLatin1StringEncoding;
                    
					source = [source stringByReplacingOccurrencesOfString:@"\r" withString:@"\r\n"];
                    
					NSString *dst = [path stringByAppendingFormat:@"/%d.%@", ++i, @"eml"];
                    
                    if([(NSString *)source writeToFile:dst
                                            atomically:YES
                                              encoding:encoding
                                                 error:nil]){
                        NSURL *url = [[NSURL alloc]initFileURLWithPath:dst isDirectory:NO];
                        if(url)
                        {
                            NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
                            C_TEXT t;
                            t.setUTF16String(path);
                            CUTF16String u16;
                            t.copyUTF16String(&u16);
                            
                            if(1)
                            {
                                std::lock_guard<std::mutex> lock(globalMutex);
                                
                                FilePromise::PATHS.push_back(u16);
                            }
                            
                            [path release];
                            
                            listenerLoopExecute();
                            [url release];
                        }
                    }
				}
			}
		}
	}	
}

void requestPromisedFiles(NSPasteboard *pboard) {

    NSURL *url = temporaryDirectory();
                
    /* prepare listener for file copy */
    [FilePromise::listener setURL:url];
    
    NSArray *filePromises = [pboard readObjectsForClasses:@[[NSFilePromiseReceiver class]] options:@{}];
    
    if(filePromises) {
                    
        for (NSFilePromiseReceiver *fileReceiver in filePromises) {
                        
            [fileReceiver receivePromisedFilesAtDestination:/*destinationDir*/url options:@{}
                                             operationQueue:[NSOperationQueue /*new*/ mainQueue]
                                                     reader:^(NSURL * fileURL, NSError * errorOrNil) {
                if (errorOrNil) {
                    
                    NSLog(@"Error: %@", errorOrNil);
                    NSLog(@"URL: %@", url);
                    return;
                }
                
                NSLog(@"fileURL: %@", fileURL);
                
            }];
            
        }
        
    }
    
}

void registeredDraggedTypes(NSWindow *window) {
    
    if(window)
    {
        NSView *contentView = [window contentView];
        if(contentView)
        {
            const char *name = class_getName([contentView class]);//NSView
            NSArray *subviews = [contentView subviews];
            if([subviews count])
            {
                NSView *mainView = [subviews objectAtIndex:0];

                [mainView registerForDraggedTypes:[NSFilePromiseReceiver readableDraggedTypes]];
                [mainView registerForDraggedTypes:@[NSFilesPromisePboardType]];/* this is critical! */

                NSArray *registeredDraggedTypes = [mainView registeredDraggedTypes];
                NSLog(@"registered types:%@", registeredDraggedTypes);
            }
        }
    }
}

NSDragOperation __swiz_draggingEntered(id self, SEL _cmd, id sender)
{
    __block NSDragOperation returnValue = ((NSDragOperation(*)(id,SEL, id))__orig_imp_draggingEntered)(self, _cmd, sender);
    
    NSLog(@"draggingEntered, NSDragOperation=%d", returnValue);
    
    if(false)
    {
        registeredDraggedTypes([sender draggingDestinationWindow]);
    }
    
    if(returnValue & NSDragOperationNone)
    {
        /* can we change the drag icon here? */
    }
    
    if(true)
    {
        NSPasteboard *pboard = [sender draggingPasteboard];
        
        [sender enumerateDraggingItemsWithOptions:
         NSDraggingItemEnumerationConcurrent forView:self
                                          classes:[NSArray arrayWithObject:[NSPasteboardItem class]]
                                    searchOptions:nil
                                       usingBlock:^(NSDraggingItem *draggingItem, NSInteger idx, BOOL *stop)
         {
            
            NSArray *types = [[draggingItem item]types];
            
            if(false)
            {
                if([types containsObject:(NSString *)kPasteboardTypeFilePromiseContent])
                {
                    NSLog(@"content types:%@", [pboard stringForType:(NSString *)kPasteboardTypeFilePromiseContent]);
                }
            }
            
            if([types containsObject:(NSString *)kPasteboardTypeFileURLPromise])
            {
//                requestPromisedFiles(pboard);
            }
            
        }];
    }
    
    return returnValue;
}

NSDragOperation __swiz_draggingUpdated(id self, SEL _cmd, id sender)
{
    __block NSDragOperation returnValue = ((NSDragOperation(*)(id,SEL, id))__orig_imp_draggingUpdated)(self, _cmd, sender);
    
    NSLog(@"draggingUpdated, NSDragOperation=%d", returnValue);
    
    if(returnValue & NSDragOperationNone)
    {
        /* can we change the drag icon here? */
    }
    
    if(true)
    {
        NSPasteboard *pboard = [sender draggingPasteboard];
        
        [sender enumerateDraggingItemsWithOptions:
         NSDraggingItemEnumerationConcurrent forView:self
                                          classes:[NSArray arrayWithObject:[NSPasteboardItem class]]
                                    searchOptions:nil
                                       usingBlock:^(NSDraggingItem *draggingItem, NSInteger idx, BOOL *stop)
         {
            
            NSArray *types = [[draggingItem item]types];
            
            if(false)
            {
                if([types containsObject:(NSString *)kPasteboardTypeFilePromiseContent])
                {
                    NSLog(@"content types:%@", [pboard stringForType:(NSString *)kPasteboardTypeFilePromiseContent]);
                }
            }
            
            if([types containsObject:(NSString *)kPasteboardTypeFileURLPromise])
            {
//                requestPromisedFiles(pboard);
            }
            
        }];
    }
    
    return returnValue;
}

BOOL __swiz_prepareForDragOperation(id self, SEL _cmd, id sender)
{
    BOOL returnValue = ((BOOL(*)(id,SEL, id))__orig_imp_prepareForDragOperation)(self, _cmd, sender);
    
    if(true)
    {
        NSPasteboard *pboard = [sender draggingPasteboard];
        
        [sender enumerateDraggingItemsWithOptions:
         NSDraggingItemEnumerationConcurrent forView:self
                                          classes:[NSArray arrayWithObject:[NSPasteboardItem class]]
                                    searchOptions:nil
                                       usingBlock:^(NSDraggingItem *draggingItem, NSInteger idx, BOOL *stop)
         {
            
            NSArray *types = [[draggingItem item]types];
            
            if(false)
            {
                if([types containsObject:(NSString *)kPasteboardTypeFilePromiseContent])
                {
                    NSLog(@"content types:%@", [pboard stringForType:(NSString *)kPasteboardTypeFilePromiseContent]);
                }
            }
            
            if([types containsObject:(NSString *)kPasteboardTypeFileURLPromise])
            {
                requestPromisedFiles(pboard);
            }
            
        }];
    }
    
    return returnValue;
}

#define kpbERMessagePasteboardType (NSString *)@"dyn.ah62d4rv4gu8ynywrqz31g2phqzkgc65yqzvg82pwqvnhw6df"
#define kpbOlxMessagePasteboardType (NSString *)@"dyn.ah62d4rv4gu800x5qtbg0n65xqfx0nydbsr4gn2xtqf3gkzd3sbwu"
#define kpbWMOutlookInternalFilePromisePboardType (NSString *)@"dyn.ah62d4rv4gu8zsxntsz4g255trre067dfsm1gc5cgrf0gnydwr700w65fnbvg82pwqvnhw6df"

BOOL __swiz_performDragOperation(id self, SEL _cmd, id sender)
{
    BOOL returnValue = ((BOOL(*)(id,SEL, id))__orig_imp_performDragOperation)(self, _cmd, sender);
    
    NSPasteboard *pboard = [sender draggingPasteboard];
    NSArray *types = [pboard types];
    
    if(PROCESS_OUTLOOK_BY_SCRIPTING)
    {
        if (([types containsObject:kpbERMessagePasteboardType])
          ||([types containsObject:kpbOlxMessagePasteboardType])
          ||([types containsObject:kpbWMOutlookInternalFilePromisePboardType])
          ||([types containsObject:(NSString *)@"WMOutlookInternalFilePromisePboardType"])
            ) {
            goto exit;
        }
            
    }
    
    /* Apple Mail */
    
    if(true)
    {
        if ([types containsObject:(NSString *)@"com.apple.mail.PasteboardTypeAutomator"])
        {
            NSArray *plist = [pboard propertyListForType:@"com.apple.mail.PasteboardTypeAutomator"];
            
            if(plist)
            {
                if([plist count])
                {
                    /* I guess the idea is to run automator/applescript based on this information, when multiple messages are dropped
                     * evidently mail.app uses file promise for a single message but automator for multiple messages (1 of which is transferred via promise in El Capitan)
                     * plist is an array of dictionaries [{account:string, id:integer, mailbox:string, subject:string}]
                     * we will skip the standard kPasteboardTypeFileURLPromise in this case
                     */
                    goto exit;
                }
            }
        }
    }
    
    if(false)
    {
        if ([types containsObject:(NSString *)@"com.apple.mail.PasteboardTypeMessageTransfer"])
        {
            /* contains the path to .mbox of the mailbox */
            NSLog(@"photoUUID:%@", [pboard stringForType:@"com.apple.mail.PasteboardTypeMessageTransfer"]);
        }
    }
    
    if(false)
    {
        if ([types containsObject:(NSString *)@"com.apple.pasteboard.promised-file-name"])
        {
            NSLog(@"%@", [pboard stringForType:@"com.apple.pasteboard.promised-file-name"]);
        }
        
        if ([types containsObject:(NSString *)@"com.apple.pasteboard.NSFilePromiseID"])
        {
            NSLog(@"%@", [pboard stringForType:@"com.apple.pasteboard.NSFilePromiseID"]);
        }
    }
    
    /* Outlook */
    
    if (([types containsObject:(NSString *)kPasteboardTypeFileURLPromise]) || ([types containsObject:@"NSPromiseContentsPboardType"]))
    {
        
    }
    
exit:
    
    return returnValue;
}

void __swiz_concludeDragOperation(id self, SEL _cmd, id sender)
{
	((void(*)(id,SEL, id))__orig_imp_concludeDragOperation)(self, _cmd, sender);
	
	NSPasteboard *pboard = [sender draggingPasteboard];
	NSArray *types = [pboard types];
    
	if(PROCESS_OUTLOOK_BY_SCRIPTING)
	{
        if (([types containsObject:kpbERMessagePasteboardType])
          ||([types containsObject:kpbOlxMessagePasteboardType])
          ||([types containsObject:kpbWMOutlookInternalFilePromisePboardType])
          ||([types containsObject:(NSString *)@"WMOutlookInternalFilePromisePboardType"])
            ) {
            NSURL *url = temporaryDirectory();
                        
            /* prepare listener for file copy */
            [FilePromise::listener setURL:url];
            
            [swizzle_XMacNSView_saisierec performSelectorInBackground:@selector(askOutlookToExport:) withObject:url];

            goto exit;;
        }
        
	}
	
	if(true)
	{
		if ([types containsObject:(NSString *)@"com.apple.mail.PasteboardTypeAutomator"])
		{
			NSURL *url = temporaryDirectory();
						
			/* prepare listener for file copy */
			[FilePromise::listener setURL:url];
			
			[swizzle_XMacNSView_saisierec performSelectorInBackground:@selector(askMailToExport:) withObject:url];
			
			goto exit;
		}
	}
	
	if(true)
	{
		if ([types containsObject:(NSString *)@"com.apple.PhotoPrintProduct.photoUUID"])
		{
			NSURL *url = temporaryDirectory();
						
			/* prepare listener for file copy */
			[FilePromise::listener setURL:url];
			
			[swizzle_XMacNSView_saisierec performSelectorInBackground:@selector(askPhotosToExport:) withObject:url];
			
			goto exit;
		}
	}
	
	if (([types containsObject:(NSString *)kPasteboardTypeFileURLPromise]) || ([types containsObject:@"NSPromiseContentsPboardType"]))
	{

        
		goto exit;
	}

	if ([types containsObject:NSFilenamesPboardType])
	{
		NSArray *plist = [pboard propertyListForType:NSFilenamesPboardType];
		
		[plist enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
			
			NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)obj, kCFURLPOSIXPathStyle, false);
			if(url)
			{
				NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
				C_TEXT t;
				t.setUTF16String(path);
				CUTF16String u16;
				t.copyUTF16String(&u16);
				
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    FilePromise::PATHS.push_back(u16);
                }

				[path release];
                [url release];
			}
			
		}];
	}
	
	exit:
	
	listenerLoopExecute();
}

#pragma mark -

void gotEvent(FSEventStreamRef stream,
							void *callbackInfo,
							size_t numEvents,
							void *eventPaths,
							const FSEventStreamEventFlags eventFlags[],
							const FSEventStreamEventId eventIds[]
							)
{
	NSArray *paths = (NSArray *)(CFArrayRef)eventPaths;
	for(NSUInteger i = 0; i < [paths count] ; ++i)
	{
		
		FSEventStreamEventFlags flags = eventFlags[i];
		
		if(flags & kFSEventStreamEventFlagItemIsFile)
		{
			if(((!(flags & kFSEventStreamEventFlagItemCreated))
				 && (flags & kFSEventStreamEventFlagItemRenamed)
				 || (flags & kFSEventStreamEventFlagItemModified)
				 )||(flags == 0x0041C500))
			{
				NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)[paths objectAtIndex:i], kCFURLPOSIXPathStyle, false);
				if(url)
				{
					NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
					C_TEXT t;
					t.setUTF16String(path);
					CUTF16String u16;
					t.copyUTF16String(&u16);
					
					if(1)
					{
						std::lock_guard<std::mutex> lock(globalMutex);
						
						FilePromise::PATHS.push_back(u16);
					}
					
					[path release];
                    [url release];
					
					listenerLoopExecute();
				}
			}
		}
	}
}

IMP __swiz_imp_draggingEntered = (IMP)__swiz_draggingEntered;
IMP __swiz_imp_draggingUpdated = (IMP)__swiz_draggingUpdated;
IMP __swiz_imp_prepareForDragOperation = (IMP)__swiz_prepareForDragOperation;
IMP __swiz_imp_performDragOperation = (IMP)__swiz_performDragOperation;
IMP __swiz_imp_concludeDragOperation = (IMP)__swiz_concludeDragOperation;

#pragma mark -

@implementation Swizzle_XMacNSView_saisierec_Class

- (id)init
{
	if(!(self = [super init])) return self;
	
#if CGFLOAT_IS_DOUBLE
	Class MainViewClass = NSClassFromString(@"XMacNSView_saisierec");// XMacNSView_saisierec < NSView < V4DNSWindow
	
	if(MainViewClass)
	{
		__orig_imp_draggingEntered =
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(draggingEntered:)),
														 __swiz_imp_draggingEntered); // Q24@0:8@16
		
		__orig_imp_draggingUpdated =
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(draggindUpdated:)),
														 __swiz_imp_draggingUpdated); // Q24@0:8@16
		
		__orig_imp_prepareForDragOperation =
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(prepareForDragOperation:)),
														 __swiz_imp_prepareForDragOperation); // c24@0:8@16
		
		__orig_imp_performDragOperation =
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(performDragOperation:)),
														 __swiz_imp_performDragOperation); // c24@0:8@16
		
		__orig_imp_concludeDragOperation =
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(concludeDragOperation:)),
														 __swiz_imp_concludeDragOperation); // v24@0:8@16
	}
#endif
	
	return self;
}

- (void)dealloc
{
#if CGFLOAT_IS_DOUBLE
	Class MainViewClass = NSClassFromString(@"XMacNSView_saisierec");
	
	if(MainViewClass)
	{
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(draggingEntered:)),
														 __orig_imp_draggingEntered);

		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(draggingUpdated:)),
														 __orig_imp_draggingUpdated);
		
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(prepareForDragOperation:)),
														 __orig_imp_prepareForDragOperation);
		
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(performDragOperation:)),
														 __orig_imp_performDragOperation);
		
		method_setImplementation(
														 class_getInstanceMethod(MainViewClass, @selector(concludeDragOperation:)),
														 __orig_imp_concludeDragOperation);
	}
#endif
}

- (void)askPhotosToExport:(NSURL *)url
{
	sb_tell_photos_to_export(url);
}

- (void)askOutlookToExport:(NSURL *)url
{
	sb_tell_outlook_to_export(url);
}

- (void)askMailToExport:(NSURL *)url
{
	sb_tell_mail_to_export(url);
}

@end

void swizzle_on()
{
#if CGFLOAT_IS_DOUBLE
	if(!swizzle_XMacNSView_saisierec)
	{
		swizzle_XMacNSView_saisierec = [[Swizzle_XMacNSView_saisierec_Class alloc]init];
	}
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);
	listenerLoopStart();
#endif
}

void swizzle_off()
{
#if CGFLOAT_IS_DOUBLE
	if(swizzle_XMacNSView_saisierec)
	{
		[swizzle_XMacNSView_saisierec release];
		swizzle_XMacNSView_saisierec = nil;
	}
	listenerLoopFinish();
#endif
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
	}
	catch(...)
	{
		
	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
    requestPermission(@"com.apple.mail");
    requestPermission(@"com.apple.Photos");
    
    requestPermission(@"com.microsoft.Outlook");/* not applicable for 3rd party apps? */
    
//NSLog(@"%@", copyDecodedDynUTI(@"dyn.ah62d4rv4gu800x5qtbg0n65xqfx0nydbsr4gn2xtqf3gkzd3sbwu"));/* ?0=6:4=kOlxMessagePasteboardType */
//NSLog(@"%@", copyDecodedDynUTI(@"dyn.ah62d4rv4gu8yc6durvwwa3xmrvw1gkdusm1044pxqyuha2pxsvw0e55bsmwca7d3sbwu"));/* ?0=6:4=Apple files promise pasteboard type */
//NSLog(@"%@", copyDecodedDynUTI(@"dyn.ah62d4rv4gu8zsxntsz4g255trre067dfsm1gc5cgrf0gnydwr700w65fnbvg82pwqvnhw6df"));/* ?0=6:4=WMOutlookInternalFilePromisePboardType */
//NSLog(@"%@", copyDecodedDynUTI(@"dyn.ah62d4rv4gu8y6y4usm1044pxqzb085xyqz1hk64uqm10c6xenv61a3k"));/* ?0=6:4=NSPromiseContentsPboardType */
//NSLog(@"%@", @"WMOutlookInternalFilePromisePboardType");

}

void OnExit()
{
    swizzle_off();
}

#pragma mark -

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;

        case kDeinitPlugin :
            OnExit();
            break;
            
			// --- Apple file promises
			
		case 1 :
			ACCEPT_FILE_PROMISES(pResult, pParams);
			break;
			
	}
}

// ------------------------------ Apple file promises -----------------------------

@implementation AppleFilePromiseListener

- (id)init
{
	if(!(self = [super init])) return self;
	
	/* setup object instance here */
	
	stream = 0;
	
	return self;
}

- (void)dealloc
{
    if(USE_FS_EVENT) {
        if(stream)
        {
            FSEventStreamStop(stream);
            FSEventStreamUnscheduleFromRunLoop (stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
            FSEventStreamInvalidate(stream);
            FSEventStreamRelease(stream);
            stream = 0;
        }
    }

	[super dealloc];
}

- (void)setURL:(NSURL *)url
{
    if(USE_FS_EVENT) {
        if(stream)
        {
            FSEventStreamStop(stream);
            FSEventStreamUnscheduleFromRunLoop (stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
            FSEventStreamInvalidate(stream);
            FSEventStreamRelease(stream);
            stream = 0;
        }
        
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
        
        FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
        NSTimeInterval latency = 1.0;
        
        stream = FSEventStreamCreate(NULL,
                                     (FSEventStreamCallback)gotEvent,
                                     &context,
                                     (CFArrayRef)@[path],
                                     kFSEventStreamEventIdSinceNow,
                                     (CFAbsoluteTime)latency,
                                     kFSEventStreamCreateFlagUseCFTypes
                                     | kFSEventStreamCreateFlagFileEvents
                                     | kFSEventStreamCreateFlagNoDefer
                                     //                                                                     | kFSEventStreamCreateFlagIgnoreSelf
                                     );
        
        FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        FSEventStreamStart(stream);
        [path release];
    }

}

@end

#pragma mark -

void listener_start()
{
    if(!FilePromise::listener)
    {
        FilePromise::listener = [[AppleFilePromiseListener alloc]init];
    }
}

void listener_end()
{
    /* must do this in main process */
    [FilePromise::listener release];
    FilePromise::listener = nil;
}

void listenerLoop()
{    
	if(1)
	{
         std::lock_guard<std::mutex> lock(globalMutex3);

		FilePromise::PROCESS_SHOULD_TERMINATE = false;
	}
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
	while(!PA_IsProcessDying())
	{
		PA_YieldAbsolute();
		
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = FilePromise::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = FilePromise::PROCESS_SHOULD_TERMINATE;
        }
        
		if(PROCESS_SHOULD_RESUME)
		{
            size_t PATHS;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                PATHS = FilePromise::PATHS.size();
            }
            
			while(PATHS)
			{
				PA_YieldAbsolute();
				
				if(CALLBACK_IN_NEW_PROCESS)
				{
					C_TEXT processName;
					generateUuid(processName);
					PA_NewProcess((void *)listenerLoopExecuteMethod,
												FilePromise::STACK_SIZE,
												(PA_Unichar *)processName.getUTF16StringPtr());
				}else
				{
					listenerLoopExecuteMethod();
				}
				
				if (PROCESS_SHOULD_TERMINATE)
					break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    PATHS = FilePromise::PATHS.size();
                    PROCESS_SHOULD_TERMINATE = FilePromise::PROCESS_SHOULD_TERMINATE;
                }
			}
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                FilePromise::PROCESS_SHOULD_RESUME = false;
            }

		}else
		{
            /* DELAY PROCESS does not work for PA_NewProcess */
			PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
		}
		
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = FilePromise::PROCESS_SHOULD_TERMINATE;
        }
        
		if (PROCESS_SHOULD_TERMINATE)
			break;
	}
	
	if(1)
	{
		std::lock_guard<std::mutex> lock(globalMutex);
		
		FilePromise::PATHS.clear();
	}
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        FilePromise::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        FilePromise::METHOD_PROCESS_ID = 0;
    }
	
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
    
	PA_KillProcess();
}

void listenerLoopStart()
{
    if(!FilePromise::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        FilePromise::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                       FilePromise::STACK_SIZE,
                                                       FilePromise::PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
	if(FilePromise::METHOD_PROCESS_ID)
	{
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            FilePromise::PROCESS_SHOULD_TERMINATE = true;
        }

		PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            FilePromise::PROCESS_SHOULD_RESUME = true;
        }
	}
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        FilePromise::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        FilePromise::PROCESS_SHOULD_RESUME = true;
    }
	
}

void listenerLoopExecuteMethod()
{
    CUTF16String __PATH;

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);

        std::vector<CUTF16String>::iterator p;
        
        p = FilePromise::PATHS.begin();
        
        __PATH = *p;
        
        FilePromise::PATHS.erase(p);
    }
    
	method_id_t methodId = PA_GetMethodID((PA_Unichar *)FilePromise::LISTENER_METHOD.getUTF16StringPtr());
	
	if(methodId)
	{
		PA_Variable	params[2];
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Unistring);
		
		PA_Unistring command = PA_CreateUnistring((PA_Unichar *)__PATH.c_str());
		PA_Unistring context = PA_CreateUnistring((PA_Unichar *)FilePromise::LISTENER_CONTEXT.getUTF16StringPtr());
	
		PA_SetStringVariable(&params[0], &command);
		PA_SetStringVariable(&params[1], &context);
		
		PA_ExecuteMethodByID(methodId, params, 2);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		
	}else
	{
		PA_Variable	params[3];
		params[1] = PA_CreateVariable(eVK_Unistring);
		params[2] = PA_CreateVariable(eVK_Unistring);
		
		PA_Unistring command = PA_CreateUnistring((PA_Unichar *)__PATH.c_str());
		PA_Unistring context = PA_CreateUnistring((PA_Unichar *)FilePromise::LISTENER_CONTEXT.getUTF16StringPtr());
		
		PA_SetStringVariable(&params[1], &command);
		PA_SetStringVariable(&params[2], &context);
		
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring method = PA_CreateUnistring((PA_Unichar *)FilePromise::LISTENER_METHOD.getUTF16StringPtr());
		PA_SetStringVariable(&params[0], &method);
		
        /* execute method */
		PA_ExecuteCommandByID(1007, params, 3);

		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		PA_ClearVariable(&params[2]);
	}
}

#pragma mark -

void ACCEPT_FILE_PROMISES(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT Param2_method;
	C_TEXT Param3_context;

	Param1.fromParamAtIndex(pParams, 1);
	
	if(!IsProcessOnExit())
	{
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex2);
            
            FilePromise::LISTENER_METHOD.fromParamAtIndex(pParams, 2);
        }
        
		if(1)
		{
			std::lock_guard<std::mutex> lock(globalMutex);

			FilePromise::LISTENER_CONTEXT.fromParamAtIndex(pParams, 3);
		}
		
		if(Param1.getIntValue())
		{
			swizzle_on();
		}else
		{
			swizzle_off();
		}
	}
}
